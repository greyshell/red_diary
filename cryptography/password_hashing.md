# Password Hashing

## Bad Practice

1. Store password in clear text:
   1. The attacker knows the all passwords directly if he compromises the database, then he can login as any users.
2. Instead of directly storing password, store a  `un-salted` hash generated by fast hashing algo like sha3 / blake.
   1. Same passwords generates same hash if we don't use `salt`. Therefore, just by looking at the two same hashes the attacker infers that those two users have the same password.



## Salt

The concept is similar to `personalize a hash function` with a key / secret  to create an `authenticated tag` / message authentication code (MAC).

1. However, Salt is `not a secret` means 
   1. we can store that in clear text. But it should not be accessible in public.
   2. We can store it in the same database but preferable saparate table from `password_hash`.

2. Salt should be generated from `csrng`(i.e os.urandom()) function.
3. Salt should be `unique` per user. Thus, two passwords don't produce the same hash.
4. Salt should be as long as the output of the hash, minimum 32 byte.

   1. If salt is too short, an attacker can again build the rainbow table for every possible salt.
5. Instead of pre-pend or postpend the salt with password, it is recommended to use appropiate hashing function where we can provide the salt as an argument.



> Q. Prepending the salt with password and use sha2 algorithm. Any issue?
>
> - **Hash length extention attack`** is not relevent here because here the attacker does not need to calculate a valid hash (by guessing the salt length). 
> - Rather, he will be more interested to find the actual password from the known hash.
> - sha2 is fast hashing algorithm and that is the main issue here because the attacker can build the rainbow table fast.



>  Q. Can we use `username` or UID as salt
>
>  1. No. Because it does not generated from `un-predictable` source / csrng(i.e os.urandom()) function.
>  3. Could be too short. Does not meet minimum 32 byte requirement.



## Papper

A **pepper** is a `secret` added (prepend / postpend) to the password during hashing.
1. This value should differs from a salt and that it is not stored alongside a password hash, but rather the pepper is kept separate in some other medium, such as a `Hardware Security Module`.
2. NIST receommended size minimum 16 byte.
3. Should be generated from `csrng`(i.e os.urandom()) function.
4. It should be `unique per application`.



## Properties required for hashing password

1. Support `Avalanche Effect` means a small changes in plain text results significantly change in cipher text.
2. General hashing properties
   1. Pre-image resistance: more important, because after having the hash, the attack want to discover the password.
   2. 2nd pre-image resistance: When the attacker know his own password and hash, he tries to find another password that produce the same hash. Therefore, if we get another same hash in the database then we can know that user either uses our password or our found password.
   3. collision resistance: the victim and the attacker `produce two different password` that generates the same hash output. Now the attacker can login to victim's account using his known password.

3. Support `slow computation` by using multiple iteration, `memory heavy operation` to deter the offline rainbow table generation.
4. Support authenticated tag like MAC, per user customization string like `salt`.
   1. This parameter should be used as separate argument to the function. 
   1. Minimum 32 bytes
5. Support for XOF / variable length digest length
   1. Minimum 32 bytes




> Q. Is there any performance impact if we use slow hashing functions.
>
> A. Yes. this intentional slow down can have an impact on the performance of an application, especially during the authentication process when users are logging in and their passwords need to be hashed and compared against stored hashes. 
>
> - To mitigate the performance impact, many applications use techniques such as parallelism, multi-threading, or specialized hardware to help mitigate the slowdown caused by slow hashing algorithms. 
>
> - Additionally, using appropriate work factor parameters when configuring the hashing algorithm can allow you to strike a balance between security and performance.



Following all key derivation functions are resistant to rainbow table attacks

1. PBKDF2 - (Not Recommended anymore)

   1. It is **not resistant** to 
      1. GPU attacks (parallel password cracking using video cards) and to 
      2. ASIC attacks (specialized password cracking hardware).
   2. Mostly known for using as KDF
   3. Flexibility to specify the hasing algorithm as argument.

2. Bcrypt

   1. **Less resistant** to ASIC and GPU attacks. 
   2. It provides configurable iterations count, but uses constant memory, so it is easier to build hardware-accelerated password crackers.
   3. salt is pre-pended with digest therefore it easily accessible by someone who has the hash.
   4.  The bcrypt algorithm only handles passwords up to 72 characters, any characters beyond that are ignored. To work around this, a common approach is to hash a password with a cryptographic hash (such as sha256) and then base64 encode it to prevent NULL byte problems before hashing the result with bcrypt.
   5. It also can be used as KDF / key generation.

3. Scrypt - (Recommended)

   1. It is memory-intensive, designed to prevent **GPU**, **ASIC** and **FPGA** based attacks (highly efficient password cracking hardware)

   2. XOF supported

   3. Shorter hash outputs are prefixes of longer hash outputs.
   
   4. Function Arguments are 

```
hash_key = Scrypt(password, salt, N, r, p, derived-key-len)

config parameters are:
1. password => the input password (8-10 chars minimal length is recommended)
2. salt => securely-generated random bytes (64 bits minimum, 128 bits recommended)
3. p => parallelism factor (threads to run in parallel, affects the memory, CPU usage), e.g. 1 
4. n => iterations count (affects memory and CPU usage), e.g. 16384 or 2048, must be power of 2 
5. r => block size (affects memory and CPU usage), e.g. 8
6. derived-key-length => how many bytes to generate as output, e.g. 32 bytes (256 bits)
```

4. Argon2 - (Recommended)

   1.  Strong resistant to GPU, ASIC and FPGA attacks.
   2. Argon2 config parameters are very similar to Scrypt.
   3. API - `argon2_cffi` lib also provides function that supports inbuild random salt generation.
   4. The Argon2 function has several variants:
      1. Argon2d – provides strong GPU resistance, but has potential side-channel attacks (possible in very special situations).
      2. Argon2i – provides less GPU resistance, but has no side-channel attacks.
      3. Argon2id – recommended (combines the Argon2d and Argon2i).



## Summary

1. Use argon2di / scrypt.
2. Use `pepper` along with the `salt` to add extra defence in depth. 
3. Don't directly string compare two hashes, if no rate limiter / captcha is use then the attacker can do `timing attack` to enumerate the password.
   1. Solution: XOR two hashes and compare with 0 or 1.
   1. python3 alternate: Use compare_digest(good_sig, sig) method from hmac lib.

```
compare_result = hmac.compare_digest(str,str)
```



## References

1. https://crackstation.net/hashing-security.htm
